---
title: "R Notebook"
output: html_notebook
---

```{r setup}
#sql chunk, db connection not available
library(DBI)
db = dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
knitr::opts_chunk$set(connection = "db")
```

### Scenario 1

- Comparison of total sales from the fiscal quarters of 2008 to the fiscal quarters of 2007
- Fiscal year is from June to July

**Test Example**

```{sql}
SELECT
a.SalesPersonID,
c.LastName,
/*add 6 months to orderdate to get fiscal year from July to June*/
YEAR(DATEADD(MONTH,6,a.OrderDate)) as FY, /*result is a year*/
DATEPART(QUARTER,DATEADD(MONTH,6,a.OrderDate)) as FQ, /*result is a number of quarter*/
SUM(a.SubTotal) as FQSales,  /*sum of sales*/
SUM(b.SubTotal) as SameSalesFQLast,  /*sum of sales*/
SUM(a.SubTotal)-SUM(b.SubTotal) as Change,  /*difference between sum of sales*/
((SUM(a.SubTotal)-SUM(b.SubTotal)) /SUM(b.SubTotal)) * 100 as pct_change  /*percentage*/
/*2018-2017/2017*/
 /*join two same tables to itself and specify dates in tables*/
  
FROM [Sales].[SalesOrderHeader] a left join [Sales].[SalesOrderHeader] b
ON a.SalesPersonID=b.SalesPersonID
/*quarters in both tables are same*/
AND DATEPART(QUARTER,DATEADD(MONTH,6,b.OrderDate))=DATEPART(QUARTER,DATEADD(MONTH,6,a.OrderDate))
/*table b is in 2008 and table a is in 2007*/
AND DATEPART(YEAR,DATEADD(MONTH,6,b.OrderDate))=DATEPART(YEAR,DATEADD(MONTH,6,a.OrderDate))-1
INNER JOIN Person.[Person] c 
ON c.BusinessEntityID=a.SalesPersonID
WHERE DATEPART(YEAR,DATEADD(MONTH,6,a.OrderDate))=2008
GROUP BY 1,2,3,4
```

**Real Example**

```{sql}
SELECT
DATEPART(YEAR,DATEADD(MONTH,6,a.impression_dt)) as FY, /*result is a year*/
DATEPART(QUARTER,DATEADD(MONTH,6,a.impression_dt)) as FQ, /*result is a number of quarter*/
COUNT(a.sudid) as FQSales,  /*sum of sales*/
COUNT(b.sudid) as SameSalesFQLast,  /*sum of sales*/
COUNT(a.sudid)-COUNT(b.sudid) as Change,  /*difference between sum of sales*/
((COUNT(a.sudid)-COUNT(b.sudid))/COUNT(b.sudid))*100 as pct_change  /*percentage*/

FROM fact_impressions a left join fact_impressions b
  ON a.sudid = b.sudid
  AND DATEPART(QUARTER,DATEADD(MONTH,6,b.impression_dt))=DATEPART(QUARTER,DATEADD(MONTH,6,a.impression_dt))
  AND DATEPART(YEAR,DATEADD(MONTH,6,b.impression_dt))=DATEPART(YEAR,DATEADD(MONTH,6,a.impression_dt))-1
WHERE DATEPART(YEAR,DATEADD(MONTH,6,a.impression_dt))=2018
  AND DATEPART(QUARTER, DATEADD(MONTH,6,a.impression_dt)) = 4
GROUP BY 1,2
```

### Scenario 2

2/22 promotion, orders subtotaling at least $\$2,000$ ship for $\$0.22$. The strategy assumes that freight losses will be offset by gains from higher value orders. Orders between $1,700 and $\$2,000$ will likely boost to $\$2,000$ as customers feel compelled to take advantage of bargain freight pricing

- Potential Promotional Effect
- Potential order gains
- Potential freight losses
- Overall net gain/loss

**Test Example**

```{sql}
SELECT 
  a.SalesOrderID, --Order ID
  a.OrderDate, -- Date
  d.Name AS Ship_to_State, -- State
  a.SubTotal AS Historical_Order_Total, -- Prior to discount
  a.Freight AS Historical_Freight, -- Prior to discount
  CASE 
    WHEN a.SubTotal>=1700 and a.SubTotal<2000 THEN 'Increase order to 2000 and pay 22 cents as Freight'
    WHEN a.SubTotal>=2000 THEN 'No Order Change but pay 22 cents as Freight' 
    ELSE 'No order change and pay historical freight' 
    END as Promo_Effect,
  CASE
    WHEN a.SubTotal>=1700 and a.SubTotal<2000 THEN 2000 - a.SubTotal 
    ELSE 0 
    END as Potential_Order_Gain,
  CASE 
    WHEN a.SubTotal>=1700 THEN 0.22 else a.Freight END  - a.Freight as PotentialFreightoss,
  (CASE 
    WHEN a.SubTotal>=1700 and a.SubTotal<2000 then 2000 -a.SubTotal 
    ELSE 0 
    END + 
      CASE 
        WHEN a.SubTotal>=1700 THEN 0.22 ELSE a.Freight 
        END )- 
          a.Freight AS PromoNetGain_Loss
FROM [Sales].[SalesOrderHeader] a
  JOIN Person.BusinessEntityAddress b ON a.ShipToAddressID=b.AddressID
  JOIN Person.[Address] c ON b.AddressID = c.AddressID
  JOIN Person.StateProvince d ON c.StateProvinceID=d.StateProvinceID
WHERE d.Name = 'California' 
  AND DATEPART (YEAR, DATEADD (MONTH, 6,a.OrderDate)) = 2008
```


### Scenario 12

You are asked to provide frequent updates about the product inventory.


**Test Example**

```{sql}
-- final table includes quantity of each product and total of all products
SELECT
  b.name,
  count(distinct a.ProductID) AS ProductCount,
  sum(a.Quantity) as ProductQty
FROM [Production].[ProductInventory] a
JOIN [Production].[Location] b ON a.LocationID=b.LocationID
GROUP BY (b.name)

UNION

SELECT 
  'Total' ,
  count(distinct a.ProductID) AS ProductCount,
  SUM(a.Quantity) as ProductQty
FROM [Production].[ProductInventory] a
```

### Scenario 13

Identify the employee or group of employees with the greatest number of vacation hours. Since many HR files are indexed by National ID Number, include the last four digits with your output.

**Test Example**

```{sql}
WITH MaxVacHrs AS 
	(SELECT MaxVacHrs = MAX (VacationHours) FROM HumanResources.Employee)
	
SELECT 
	RIGHT (N1.NationalIDNumber, 4) AS NationalID,
	N2.FirstName,
	N2.LastName,
	N1.JobTitle,
	N1.VacationHours
FROM HumanResources.Employee N1
  INNER JOIN Person.Person N2 ON N1.BusinessEntityID = N2.BusinessEntityID
  INNER JOIN MaxVacHrs N3 ON N1.VacationHours = N3.MaxVacHrs
```

### Scenario 14

For each product ordered by the Purchasing Department in 2007, indicate the quantity ordered by order date.

```{sql}
SELECT 
  b.ProductID,
  c.Name,
  a.OrderDate,
  sum(b.OrderQty) as QTY
FROM [Purchasing].[PurchaseOrderHeader] a 
  JOIN [Purchasing].[PurchaseOrderDetail] b ON a.PurchaseOrderID=b.PurchaseOrderID 
  JOIN [Production].[Product] c ON b.ProductID=c.ProductID
WHERE DATEPART(YEAR, a.OrderDate)=2007
GROUP BY  1,2,3
ORDER BY sum(b.OrderQty) DESC
```

### Scenario 15

List of all product descriptions written in languages other than English.

```{sql}
SELECT
  a.ProductModelID,
  a.Name,
  c.Description,
  b.CultureID
FROM [Production].[ProductModel] a
  JOIN [Production].[ProductModelProductDescriptionCulture] b ON a.ProductModelID=b.ProductModelID 
  JOIN  [Production].[ProductDescription] c ON b.ProductDescriptionID=c.ProductDescriptionID
WHERE b.CultureID != 'en'
```

### Scenario 20

Provide address data about stores with main offices located in Toronto.

```{sql}
SELECT 
  d.Name AS StoreName,
  a.AddressLine1,
  a.AddressLine2,
  a.City,c.Name,
  a.PostalCode
FROM [Person].[Address] a JOIN [Person].[BusinessEntityAddress] b ON a.AddressID=b.AddressID 
  JOIN [Person].[StateProvince] c  ON a.StateProvinceID=c.StateProvinceID
  JOIN [Sales].[Store] d ON d.BusinessEntityID=b.BusinessEntityID
WHERE b.AddressTypeID=3 -- or d.name = 'Main Office'
  AND a.City='Toronto'
```

### Scenario 21

List of employees who are currently in the Marketing department and were hired prior to 2002 or later than 2004.

```{sql}
SELECT
  d.FirstName,
  d.LastName,
  c.JobTitle,
  c.BirthDate,
  c.MaritalStatus,
  a.StartDate AS Hire_Date
FROM [HumanResources].[EmployeeDepartmentHistory] a 
  JOIN [HumanResources].[Department] b ON a.DepartmentID=b.DepartmentID
  JOIN [HumanResources].[Employee] c ON c.BusinessEntityID=a.BusinessEntityID
  JOIN  [Person].[Person] d ON d.BusinessEntityID=a.BusinessEntityID
WHERE 
  (DATEPART(YEAR, a.StartDate)<2002 
    OR DATEPART(YEAR, a.StartDate)>2004) 
  AND b.Name='Marketing' 
  AND a.EndDate IS NULL
```

### Scenario 22

Who left that review?

```{sql}
SELECT
  a.ProductReviewID,
  a.ProductID,
  b.Name,
  a.ReviewerName,
  a.Rating,
  a.EmailAddress,
  c.BusinessEntityID -- will be returned as 0
FROM [Production].[ProductReview] a 
JOIN [Production].[Product] b ON a.ProductID=b.ProductID
LEFT JOIN [Person].[EmailAddress] c ON a.EmailAddress=c.EmailAddress
```

### Scenario 23

List of customers with phone numbers for all orders for shorts placed online after July 7, 2008.

```{sql}
SELECT
  a.SalesOrderID,
  a.OrderDate,
  c.Name,
  f.FirstName,
  f.LastName,
  g.PhoneNumber
FROM [Sales].[SalesOrderHeader] a 
  INNER JOIN [Sales].[SalesOrderDetail] b ON a.SalesOrderID=b.SalesOrderID
  INNER JOIN [Production].[Product] c ON b.ProductID=c.ProductID
  INNER JOIN [Sales].[Customer] e ON e.CustomerID=a.CustomerID
  INNER JOIN [Person].[Person] f ON e.PersonID=f.BusinessEntityID
  INNER JOIN [Person].[PersonPhone] g ON g.BusinessEntityID=f.BusinessEntityID
WHERE a.OrderDate>'2008-07-07' 
 AND a.OnlineOrderFlag=1 
 AND LOWER(c.Name) LIKE '%shorts%'
ORDER BY a.SalesOrderID
```

### Scenario 19

Display the most common reasons why products were scrapped through the manufacturing process.

```{sql}
WITH Temp AS 
	(SELECT
		ROW_NUMBER () OVER (PARTITION BY N1.ProductID 
												ORDER BY COUNT (N2.Name) DESC) AS rank, --name is the reason why it was scrapped
		N1.ProductID
		ProductName AS N2.Name
		COUNT (N2.Name) AS WorkOrderCount
		N3.Name AS ScrapReason
	FROM Production.WorkOrder N1
		INNER JOIN Production.Product N2 ON N1.ProductID = N2.ProductID
		INNER JOIN Production.ScrapReason N3 ON N1.ScrapReasonID = N3.ScrapReasonID
		GROUP BY N1.ProductID, N2.Name, N3.Name)

SELECT
	ProductID,
	ProductName,
	WorkOrderCount,
	ScrapReason
FROM Temp
WHERE rank = 1
ORDER BY WorkOrderCount DESC
```

### Solution 18

- minimium historical cost
- maximum historical cost
- historical cost variablity - maximum minus minimum
- ranking of all historical cost variablities - rank of 1 reflects the product ID exhibiting the greatetist historical cost variability

```{sql}
-- ROW_NUMBER – Returns the sequential number of a row within a partition of a result set, without any gaps in the ranking. ... The rank of a row is one plus the number of ranks that come before the row in question.

--DENSE_RANK – Returns the rank of rows within the partition of a result set, without any gaps in the ranking

SELECT 
	N1.ProductID
	N2.Name AS ProductName
	N3.Name AS SubCategory
	MIN (N1.StandardCost) AS MinCost
  MAX (N1.StandardCost) AS 	MaxCost
	MAX (N1.StandardCost) - MIN (N1.StandardCost) AS CostVar

	CASE 
			WHEN MAX (N1.StandardCost) - MIN (N1.StandardCost) = 0 THEN 0 
			ELSE DENSE_RANK () OVER (ORDER BY MAX (N1.StandardCost) - MIN     (N1.StandardCost) DESC) 
			END AS CostVarRank -- gives a number to each row based on difference in standard cost	

FROM Production.ProductCostHistory N1
  INNER JOIN Production.Product N2 ON N1.ProductID = N2.ProductID
  INNER JOIN Production.ProductSubcategory N3 ON N2.ProductSubcategoryID = N3.ProductSubcategoryID
GROUP BY N1.ProductID, N2.[Name], N3.[Name]
ORDER BY MAX (N1.StandardCost) - MIN (N1.StandardCost) DESC
```

### Solution 17

Identify stores in which the last order date was at least 12 months ago (today's date is October 7, 2008)

```{sql}
WITH Stores AS

(SELECT
	N3.BusinessEntityID,
	N1.CustomerID,
	N2.StoreID,
	N3.Name AS StoreName
	MAX (N1.OrderDate) AS LastOrderDate
	DATEDIFF (MONTH, MAX (N1.OrderDate), '2008-10-07') AS MonthsSinceLastOrder
FROM Sales.SalesOrderHeader N1
  INNER JOIN Sales.Customer N2 ON N1.CustomerID = N2.CustomerID
  INNER JOIN Sales.Store N3 ON N2.StoreID = N3.BusinessEntityID
GROUP BY 1,2,3,4)

SELECT * 
FROM Stores
WHERE MonthsSinceLastOrder > = 12
ORDER BY MonthsSinceLastOrder DESC
```

### Solution 16

summary table that shows, by territory, the percentage of orders placed online in comparison to orders not placed online

```{sql}
SELECT
	TerritoryID,
	COUNT(*) AS TotalOrders,
	CONVERT(VARCHAR(50), -- to add % after a calculation
	  ROUND( -- to round the calculation to the whole number
	    (CONVERT(FLOAT, -- to calculate with float 
	      SUM(CASE -- calculation itself
	        WHEN OnlineOrderFlag = 1 
	        THEN 1 
	        ELSE 0 
	        END)) /COUNT(*))* 100
	   ,0)
	  ) 
	 + '%' AS PercOnline

	CONVERT(VARCHAR(50),
		ROUND(
			(CONVERT(FLOAT,
				SUM(CASE 
				  WHEN OnlineOrderFlag = 0 
				  THEN 1 ELSE 0 
				  END)) /COUNT(*))* 100
			,0)
			)
	+ '%' AS PercOffline
FROM Sales.SalesOrderHeader
GROUP BY TerritoryID
ORDER BY TerritoryID
```


### Solution 11

max tax rate in each country

```{sql}
SELECT
	N3.Name AS Country,
	MAX (N1.TaxRate) AS MaxTaxRate
FROM Sales.SalesTaxRate N1
  INNER JOIN Person.StateProvince N2 ON N1.StateProvinceID = N2.StateProvinceID
  INNER JOIN Person.CountryRegion N3 ON N2.CountryRegionCode = N3.CountryRegionCode
GROUP BY 1
```

### Solution 4

compare sales from Tuesday to other days of the week; calculate average reveniue per order by day of week in 2008

```{sql}
SELECT 
	DATENAME (WEEKDAY, OrderDate) AS DayCategory,
	SUM (Subtotal) AS Revenue,
	COUNT (*) AS Orders,
	SUM (Subtotal) / COUNT (*) AS RevenuePerOrder
FROM Sales.SalesOrderHeader
WHERE DATEPART(YEAR, OrderDate) = 2008
AND OnlineOrderFlag = 0
GROUP BY 1
ORDER BY RevenuePerOrder DESC
```

